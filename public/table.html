<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Flipâ€‘toâ€‘6 â€” Game Table v1.0.2</title>

<style>
/* ============================================================
   GENERAL PAGE STYLE
============================================================ */
body {
  font-family: Arial, sans-serif;
  background: #304730;
  color: #fff;
  text-align: center;
  margin: 0;
  padding: 0;
}

#status {
  margin: 10px;
  font-weight: bold;
  color: #fff;
}

/* ============================================================
   ACCORDION
============================================================ */
details {
  border: 1px solid #ccc;
  border-radius: 6px;
  margin: 6px auto;
  width: 95%;
  background: #222;
}
summary {
  cursor: pointer;
  padding: 5px 0px;
  font-weight: 600;
  list-style: none;
}
summary::before {
  content: "â–¶";
  font-size: 0.9em;
  margin-right: 8px;
  transition: transform 0.2s ease;
  display: inline-block;
}
details[open] summary::before {
  transform: rotate(90deg);
}
details > div {
  padding: 6px 6px;
  border-top: 1px solid #444;
  background: #333;
}

/* ============================================================
   TABLE LAYOUT (6 SEATS)
============================================================ */
table.playing-table {
  margin: 5px auto;
  border-collapse: collapse;
  table-layout: fixed;
  width: 1200px;
}
.playing-table td {
  border: 2px solid #444;
  padding: 10px;
  vertical-align: top;
  background: #0a7f4f;
  border-radius: 8px;
}

/* Middle column default: centered vertically */
.playing-table tr td:nth-child(2) {
  background: #7992BA;
  vertical-align: middle;
}

/* Row 3 middle column override: TOP aligned */
.playing-table tr:nth-child(3) td:nth-child(2) {
  vertical-align: top;
}

/* ============================================================
   PLAYER NAME
============================================================ */
.player-name {
  font-weight: bold;
  margin-bottom: 10px;
  font-size: 1.1em;
}

/* ============================================================
   CARD SLOTS
============================================================ */
.card-row {
  display: flex;
  justify-content: center;
  gap: 6px;
  margin-bottom: 5px;
}
.card {
  position: relative;
  width: 70px;
  height: 100px;
  border-radius: 6px;
  overflow: hidden; /* ensures clean edges */
}

.card img {
  position: absolute;
  top: 0;
  left: 0;
  width: 70px;
  height: 100px;
  border: 3px solid #000;
  border-radius: 6px;
  object-fit: cover; /* ensures no stretching */
}

.yellow-card {
  position: absolute;
  top: 0;
  left: 0;
  width: 70px;
  height: 100px;
  background: #ffeb3b; /* bright yellow */
  border: 3px solid #000;
  border-radius: 6px;
}

/* ============================================================
   DECK AREA
============================================================ */
.deck {
  position: relative;
  width: 80px;
  height: 110px;
  margin: 40px auto;
  cursor: pointer;
  user-select: none;
}
.deck.disabled {
  pointer-events: none;
  opacity: 0.5;
  cursor: not-allowed;
}
.deck .card {
  position: absolute;
  top: 0;
  left: 0;
}

   /* ------------------------------
   FULL DECK THICKNESS STEPS
   ------------------------------ */

.deck.step1 .card:nth-child(2) { top: 6px; left: 6px; }
.deck.step1 .card:nth-child(3) { top: 12px; left: 8px; }
.deck.step1 .card:nth-child(4) { top: 18px; left: 10px; }
.deck.step1 .card:nth-child(5) { top: 24px; left: 14px; }

.deck.step2 .card:nth-child(2) { top: 5px; left: 5px; }
.deck.step2 .card:nth-child(3) { top: 10px; left: 10px; }
.deck.step2 .card:nth-child(4) { top: 15px; left: 15px; }
.deck.step2 .card:nth-child(5) { top: 20px; left: 20px; }

.deck.step3 .card:nth-child(2) { top: 4px; left: -6px; }
.deck.step3 .card:nth-child(3) { top: 8px; left: 2px; }
.deck.step3 .card:nth-child(4) { top: 12px; left: 18px; }
.deck.step3 .card:nth-child(5) { top: 16px; left: 12px; }

.deck.step4 .card:nth-child(2) { top: 3px; left: -10px; }
.deck.step4 .card:nth-child(3) { top: 6px; left: 0px; }
.deck.step4 .card:nth-child(4) { top: 9px; left: 10px; }
.deck.step4 .card:nth-child(5) { top: 12px; left: 18px; }

.deck.step5 .card:nth-child(2) { top: 0px; left: -1px; transform: rotate(-1deg); }
.deck.step5 .card:nth-child(3) { top: 1px; left: 1px; transform: rotate(-1deg); }
.deck.step5 .card:nth-child(4) { top: 2px; left: 5px; transform: rotate(-1deg); }
.deck.step5 .card:nth-child(5) { top: 3px; left: 0px; transform: rotate(0deg); }

.deck.step6 .card:nth-child(3) { top: 2px; left: 2px; }
.deck.step6 .card:nth-child(4) { top: 3px; left: 3px; }
.deck.step6 .card:nth-child(5) { top: 4px; left: 4px; }

.deck.step7 .card:nth-child(2) { top: 0px; left: 0px; }
.deck.step7 .card:nth-child(3) { top: 1px; left: 1px; }
.deck.step7 .card:nth-child(4) { top: 2px; left: 2px; }
.deck.step7 .card:nth-child(5) { top: 3px; left: 3px; }

.deck.step8 .card:nth-child(2) { top: 0px; left: 0px; }
.deck.step8 .card:nth-child(3) { top: 0px; left: 0px; }
.deck.step8 .card:nth-child(4) { top: 1px; left: 1px; }
.deck.step8 .card:nth-child(5) { top: 2px; left: 2px; }

.deck.step9 .card:nth-child(2),
.deck.step9 .card:nth-child(3),
.deck.step9 .card:nth-child(4),
.deck.step9 .card:nth-child(5) {
  top: 0;
  left: 0;
}

.deck.step10 .card {
  display: none;
}
.deck.step10::before {
  content: "Empty";
  color: #fff;
  font-weight: bold;
  font-size: 1.2em;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 70px;
  height: 100px;
  border: 2px dashed #fff;
  border-radius: 6px;
  margin: auto;
}


   
.deck-clickable {
  cursor: pointer;
}
   
#deck.placeholder::before {
  content: "Click to Start";
  display: flex;
  align-items: center;
  justify-content: center;
  width: 70px;
  height: 100px;
  border: 2px dashed #fff;
  border-radius: 6px;
  margin: auto;
  color: #fff;
  font-weight: bold;
}

/* ============================================================
   DISCARD AREA
============================================================ */
td.discard-cell {
  text-align: center;
  vertical-align: top;
  padding: 10px 0;
}
#discard-pile.empty::before {
  content: "Empty";
  color: #fff;
  font-weight: bold;
  font-size: 1.1em;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 70px;
  height: 100px;
  border: 2px dashed #fff;
  border-radius: 6px;
  margin: auto;
}

/* ============================================================
   BUTTONS (Stay + Pass)
============================================================ */
.stay-button {
  background-color: #3f3f4f;
  color: #fff;
  font-size: 1.1em;
  font-weight: bold;
  padding: 18px 22px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  display: block;
  width: 100%;
  margin-bottom: 10px;
}
.stay-button:hover {
  background-color: #1ff233;
}

.end-turns-button {
  background-color: #6D1AA1;
  color: #fff;
  font-size: 1.1em;
  font-weight: bold;
  padding: 20px 8px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  margin-bottom: 8px;
}
.end-turns-button:hover {
  background-color: #1ff233;
}
.end-turns-button:disabled {
  background-color: #555 !important;
  color: #999 !important;
  cursor: not-allowed;
  opacity: 0.6;
}

/* ============================================================
   AUDIO CONTROLS
============================================================ */
.controls-audio {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 10px;
  justify-content: center;
}
.controls-audio label {
  font-size: 0.9em;
}
#volume-slider {
  accent-color: #1ff233;
}
.sound-item.selected {
  background: #1ff233;
  color: #000;
  border-radius: 6px;
}

/* ============================================================
   PLAYER HIGHLIGHTING
============================================================ */
.active-player {
  outline: 5px solid yellow;
  outline-offset: -5px;
  background-color: #c9b800 !important;
}
.stayed-player {
  outline: 5px solid red;
  outline-offset: -5px;
  background-color: #8b0000 !important;
}

/* ============================================================
   TARGET SELECTION MODE
============================================================ */
.target-eligible {
  outline: 5px solid #00ffea;
  outline-offset: -5px;
  cursor: pointer;
}
.target-ineligible {
  opacity: 0.3;
}

/* ============================================================
   PAUSE OVERLAY
============================================================ */
#pause-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(20, 20, 20, 0.85);
  color: #fff;
  font-size: 2em;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

/* ============================================================
   FLYING CARD ANIMATION
============================================================ */
.flying-card {
  position: fixed;
  width: 70px;
  height: 100px;
  border-radius: 6px;
  border: 3px solid #000;
  pointer-events: none;
  z-index: 999;
  transition: transform 0.4s ease-out, opacity 0.4s ease-out;
}

.dealer-chip {
  display: inline-block;
  background: gold;
  color: black;
  font-weight: bold;
  border-radius: 50%;
  width: 22px;
  height: 22px;
  text-align: center;
  line-height: 22px;
  margin-right: 6px;
  border: 2px solid #000;
  box-shadow: 0 0 4px rgba(0,0,0,0.4);
  font-size: 14px;
}

.final-round #table {
  background-color: white !important;
}

   
</style>
</head>

<body>

<!-- ============================================================
     PAUSE OVERLAY
============================================================ -->
<div id="pause-overlay">Game Paused â€” Waiting for Playerâ€¦</div>

<!-- ============================================================
     CONTROLS
============================================================ -->
<details open>
  <summary>Controls</summary>
  <div>
    <input id="removeName" placeholder="Player name to remove" style="margin-right:8px;">
    <button id="removeBtn">Remove Player</button>

    <div class="controls-audio" style="gap:15px;">
      <button id="mute-toggle">Mute</button>
      <label>
        Volume:
        <input id="volume-slider" type="range" min="0" max="100" value="40">
      </label>
      <button id="test-sounds-btn">Test Sounds</button>
    </div>
  </div>
</details>

<!-- ============================================================
     PLAYING TABLE
============================================================ -->
<details open>
  <summary>Playing Table</summary>

  <div id="status"></div>
   
  <div>
    <table class="playing-table">
      <colgroup>
        <col style="width: 45%;">
        <col style="width: 10%;">
        <col style="width: 45%;">
      </colgroup>
      <tbody>

        <!-- ROW 1 â€” Seats 1 & 2 + Discard -->
        <tr>
          <td id="seat1">
            <div class="player-name">Seat 1</div>
            <div class="card-row">
              <div class="card"></div><div class="card"></div><div class="card"></div>
              <div class="card"></div><div class="card"></div><div class="card"></div><div class="card"></div>
            </div>
            <div class="card-row second-row">
              <div class="card"></div><div class="card"></div><div class="card"></div>
              <div class="card"></div><div class="card"></div><div class="card"></div><div class="card"></div>
            </div>
          </td>

          <td class="discard-cell">
            <button id="end-turns" class="end-turns-button" disabled>End Round</button>
            <div id="discard-pile" class="deck empty"></div>
            <div id="discard-count">Discarded: 0</div>
          </td>

          <td id="seat2">
            <div class="player-name">Seat 2</div>
            <div class="card-row">
              <div class="card"></div><div class="card"></div><div class="card"></div>
              <div class="card"></div><div class="card"></div><div class="card"></div><div class="card"></div>
            </div>
            <div class="card-row second-row">
              <div class="card"></div><div class="card"></div><div class="card"></div>
              <div class="card"></div><div class="card"></div><div class="card"></div><div class="card"></div>
            </div>
          </td>
        </tr>
        <!-- ROW 2 â€” Seats 3 & 4 + Deck -->
        <tr>
          <td id="seat3">
            <div class="player-name">Seat 3</div>
            <div class="card-row">
              <div class="card"></div><div class="card"></div><div class="card"></div>
              <div class="card"></div><div class="card"></div><div class="card"></div><div class="card"></div>
            </div>
            <div class="card-row second-row">
              <div class="card"></div><div class="card"></div><div class="card"></div>
              <div class="card"></div><div class="card"></div><div class="card"></div><div class="card"></div>
            </div>
          </td>

          <!-- Deck -->
          <td class="deck-cell">
            <div class="player-name deck-label">Deck</div>
            <div class="deck placeholder" id="deck"></div>
            <div id="deck-count">0 cards</div>
          </td>

          <td id="seat4">
            <div class="player-name">Seat 4</div>
            <div class="card-row">
              <div class="card"></div><div class="card"></div><div class="card"></div>
              <div class="card"></div><div class="card"></div><div class="card"></div><div class="card"></div>
            </div>
            <div class="card-row second-row">
              <div class="card"></div><div class="card"></div><div class="card"></div>
              <div class="card"></div><div class="card"></div><div class="card"></div><div class="card"></div>
            </div>
          </td>
        </tr>

        <!-- ROW 3 â€” Seats 5 & 6 + Stay/Pass Buttons -->
        <tr>
          <td id="seat5">
            <div class="player-name">Seat 5</div>
            <div class="card-row">
              <div class="card"></div><div class="card"></div><div class="card"></div>
              <div class="card"></div><div class="card"></div><div class="card"></div><div class="card"></div>
            </div>
            <div class="card-row second-row">
              <div class="card"></div><div class="card"></div><div class="card"></div>
              <div class="card"></div><div class="card"></div><div class="card"></div><div class="card"></div>
            </div>
          </td>

          <!-- Stay + Pass buttons (vertical layout) -->
         <td class="stay-cell">
         
           <div id="round-display"
                style="font-size: 1.4em; font-weight: bold; margin-bottom: 10px;">
             Round 1
           </div>
         
           <button id="stay-button" class="stay-button">ðŸª¬ Stay</button>
           <button id="pass-button" class="stay-button">ðŸ¡† Pass</button>
         </td>


          <td id="seat6">
            <div class="player-name">Seat 6</div>
            <div class="card-row">
              <div class="card"></div><div class="card"></div><div class="card"></div>
              <div class="card"></div><div class="card"></div><div class="card"></div><div class="card"></div>
            </div>
            <div class="card-row second-row">
              <div class="card"></div><div class="card"></div><div class="card"></div>
              <div class="card"></div><div class="card"></div><div class="card"></div><div class="card"></div>
            </div>
          </td>
        </tr>

      </tbody>
    </table>
  </div>

</details>

<!-- ============================================================
     SCORING
============================================================ -->
<details>
  <summary>Scoring</summary>
  <div>
    <p>Scores are tracked server-side per round and total.</p>
  </div>
</details>

<!-- Sound Test Popup -->
<div id="sound-popup" 
     style="display:none; position:fixed; top:50%; left:50%; 
            transform:translate(-50%, -50%); background:#222; 
            padding:20px; border-radius:10px; z-index:99999; 
            width:300px; text-align:left; border:2px solid #fff;">
  
  <h3 style="margin-top:0;">Test Sounds</h3>

  <ul id="sound-list" style="list-style:none; padding:0; margin:0;">
    <li class="sound-item" data-sound="draw" style="padding:6px; cursor:pointer;">draw.mp3</li>
    <li class="sound-item" data-sound="shuffle" style="padding:6px; cursor:pointer;">shuffle.mp3</li>
    <li class="sound-item" data-sound="bust" style="padding:6px; cursor:pointer;">bust.mp3</li>
    <li class="sound-item" data-sound="secondChance" style="padding:6px; cursor:pointer;">secondChance.mp3</li>
    <li class="sound-item" data-sound="sixMinus" style="padding:6px; cursor:pointer;">6-.mp3</li>
    <li class="sound-item" data-sound="action" style="padding:6px; cursor:pointer;">action.mp3</li>
  </ul>

  <button id="close-sound-popup" 
          style="margin-top:15px; width:100%; padding:8px;">Close</button>
</div>

<div id="second-chance-popup"
     style="display:none; position:fixed; top:50%; left:50%;
            transform:translate(-50%, -50%); background:#222;
            padding:20px; border-radius:10px; z-index:99999;">
  <p>Use Second Chance?</p>
  <button id="sc-yes">Yes</button>
  <button id="sc-no">No</button>
</div>

<!-- ============================================================
     SOCKET.IO + GAME LOGIC
============================================================ -->
<script src="/socket.io/socket.io.js"></script>
<script>
/* ============================================================
   SIMPLE SANITIZATION HELPERS
   (Display + wire-level; server should still validate)
============================================================ */

/**
 * Sanitize a name for display and sending:
 * - Remove anything except letters, numbers, spaces, underscore, hyphen
 * - Limit to 32 characters
 */
function sanitizeNameSafe(input) {
  if (typeof input !== "string") return "";
  return input.replace(/[^A-Za-z0-9 _-]/g, "").substring(0, 32);
}

/**
 * Sanitize room code from URL:
 * - Only Aâ€“Z and 0â€“9
 * - Uppercase
 * - Max length 16
 */
function sanitizeRoomCodeSafe(input) {
  if (typeof input !== "string") return "";
  return input.replace(/[^A-Za-z0-9]/g, "").substring(0, 16).toUpperCase();
}

/* ============================================================
   URL PARAMS (SANITIZED)
============================================================ */
const urlParams = new URLSearchParams(window.location.search);

// Player ID from query string; ensure it is a finite positive integer
const rawPlayerId = urlParams.get("playerId");
const playerId = Number.isFinite(parseInt(rawPlayerId, 10))
  ? parseInt(rawPlayerId, 10)
  : null;

// Room code taken from last segment of path; sanitize strictly
const rawRoomCode = window.location.pathname.split("/").pop() || "";
const roomCode = sanitizeRoomCodeSafe(rawRoomCode);

// Basic guard: if we don't have valid identifiers, stop and show error
if (!playerId || !roomCode) {
  alert("Invalid room link. Please rejoin from the main page.");
}

/* ============================================================
   SOCKET
============================================================ */
const socket = io();

/* ============================================================
   DOM ELEMENTS
============================================================ */
const statusDiv = document.getElementById("status");
const deckDiv = document.getElementById("deck");
const discardPileDiv = document.getElementById("discard-pile");
const discardCountDiv = document.getElementById("discard-count");
const deckCountDiv = document.getElementById("deck-count");
const stayButton = document.getElementById("stay-button");
const passButton = document.getElementById("pass-button");
const endTurnsButton = document.getElementById("end-turns");
const removeNameInput = document.getElementById("removeName");
const removeBtn = document.getElementById("removeBtn");
const pauseOverlay = document.getElementById("pause-overlay");
const muteToggleBtn = document.getElementById("mute-toggle");
const volumeSlider = document.getElementById("volume-slider");

// Disable discard pile completely
discardPileDiv.style.pointerEvents = "none";
discardPileDiv.style.cursor = "not-allowed";

let controlsClosedOnce = false;
let hasDrawnThisTurn = false;
 

/* ============================================================
   SEAT MAPPING
============================================================ */
const seatIds = ["seat1", "seat2", "seat3", "seat4", "seat5", "seat6"];

/* ============================================================
   AUDIO SYSTEM
============================================================ */
const sounds = {
  draw: new Audio("/sounds/draw.mp3"),
  shuffle: new Audio("/sounds/shuffle.mp3"),
  bust: new Audio("/sounds/bust.mp3"),
  secondChance: new Audio("/sounds/secondChance.mp3"),
  sixMinus: new Audio("/sounds/6-.mp3"),
  action: new Audio("/sounds/action.mp3")
};

let isMuted = false;
let volumeLevel = 0.9;

// Preload and set initial volume
Object.values(sounds).forEach(s => {
  s.preload = "auto";
  s.volume = volumeLevel;
});

/**
 * Safely play a sound by name, respecting mute + volume.
 * Clones the Audio node so overlapping sounds can play.
 */
function playSound(name) {
  if (isMuted) return;
  const original = sounds[name];
  if (!original) return;

  const s = original.cloneNode();
  s.volume = volumeLevel;
  s.play().catch(() => {
    // Ignore playback errors (e.g., autoplay restrictions)
  });
}

// Volume slider (clamped 0â€“100)
volumeSlider.addEventListener("input", () => {
  const val = parseInt(volumeSlider.value, 10);
  const clamped = Number.isFinite(val) ? Math.max(0, Math.min(100, val)) : 90;
  volumeLevel = clamped / 100;
});

// Mute toggle
muteToggleBtn.addEventListener("click", () => {
  isMuted = !isMuted;
  muteToggleBtn.textContent = isMuted ? "Unmute" : "Mute";
});

/* ============================================================
   CARD METADATA (value â†’ filename)
============================================================ */
let cardMeta = {};

/**
 * Load card metadata from server and build value â†’ filename map.
 * Server controls filenames; they are used only in src attributes.
 */
async function loadCardMeta() {
  try {
    const res = await fetch("/api/cards/meta");
    const data = await res.json();
    if (data && data.success && Array.isArray(data.cards)) {
      data.cards.forEach(c => {
        if (c && typeof c.value === "string" && typeof c.filename === "string") {
          cardMeta[c.value] = c.filename;
        }
      });
    }
  } catch (err) {
    console.error("Error loading card metadata:", err);
  }
}

/**
 * Get image src for a given card value; fall back to "<value>.png".
 */
function getCardImgSrc(value) {
  const filename = cardMeta[value] || (value + ".png");
  return "/cards/" + filename;
}

/* ============================================================
   ROUND SCORE CALC (client-side mirror)
============================================================ */
function computeRoundScore(values) {
  let score = 0;
  let mult = 1;

  for (const v of values) {
    const num = parseInt(v, 10);
    if (!isNaN(num)) {
      score += num;
      continue;
    }
    if (v === "2x") mult *= 2;
    if (v === "4+") score += 4;
    if (v === "5+") score += 5;
    if (v === "6-") score -= 6;
  }

  return score * mult;
}

/* ============================================================
   GLOBAL STATE REFERENCES
============================================================ */
let currentState = null;
let lastState = null;

/* ============================================================
   FLICK / ARC ANIMATION HELPERS
============================================================ */
function getFlickAnimationForSeat(seatIndex) {
  const isLeft = (seatIndex === 0 || seatIndex === 2 || seatIndex === 4);
  const isTop = (seatIndex === 0 || seatIndex === 1);
  const isBottom = (seatIndex === 4 || seatIndex === 5);

  const direction = isLeft ? "left" : "right";

  let arcY = 0;
  if (isTop) arcY = -40;
  else if (isBottom) arcY = 40;

  return { direction, arcY };
}

function animateCardToSeat(value, seatIndex) {
  const deckRect = deckDiv.getBoundingClientRect();
  const seatId = seatIds[seatIndex];
  const seatCell = document.getElementById(seatId);
  if (!seatCell) return;

  const targetRow = seatCell.querySelector(".second-row") || seatCell;
  const targetRect = targetRow.getBoundingClientRect();

  const imgSrc = getCardImgSrc(value);

  const flying = document.createElement("img");
  flying.src = imgSrc;
  flying.className = "flying-card";
  flying.style.left = (deckRect.left + deckRect.width / 2 - 35) + "px";
  flying.style.top = (deckRect.top + deckRect.height / 2 - 50) + "px";
  flying.style.transform = "translate(0px, 0px)";
  flying.style.opacity = "1";

  document.body.appendChild(flying);

  const dx = (targetRect.left + targetRect.width / 2) - (deckRect.left + deckRect.width / 2);
  const dy = (targetRect.top + targetRect.height / 2) - (deckRect.top + deckRect.height / 2);

  const { direction, arcY } = getFlickAnimationForSeat(seatIndex);

  requestAnimationFrame(() => {
    const translateX = dx;
    const translateY = dy + arcY;
    const rotateDeg = direction === "left" ? -20 : 20;

    flying.style.transform = `translate(${translateX}px, ${translateY}px) rotate(${rotateDeg}deg)`;
    flying.style.opacity = "0";
  });

  setTimeout(() => {
    if (flying && flying.parentNode) {
      flying.parentNode.removeChild(flying);
    }
  }, 450);
}

let currentStep = 1;
let maxDeckSize = totalCards;

function updateDeckStep() {
  let percent = (totalCards / maxDeckSize) * 100;
  let newStep;

  if (totalCards === 0) newStep = 10;
  else if (percent > 90) newStep = 1;
  else if (percent > 75) newStep = 2;
  else if (percent > 60) newStep = 3;
  else if (percent > 50) newStep = 4;
  else if (percent > 40) newStep = 5;
  else if (percent > 30) newStep = 6;
  else if (percent > 20) newStep = 7;
  else if (percent > 10) newStep = 8;
  else newStep = 9;

  deck.classList.remove(`step${currentStep}`);
  currentStep = newStep;
  deck.classList.add(`step${currentStep}`);
}


   
/* ============================================================
   RENDER DECK
============================================================ */
function renderDeck(state) {
  deckDiv.innerHTML = "";

  // No deck yet
  if (!state || typeof state.deckCount !== "number" || state.deckCount === 0) {
    deckDiv.classList.add("placeholder");
    deckCountDiv.textContent = "0 cards";
    return;
  }

  deckDiv.classList.remove("placeholder");

  const topCards = Array.isArray(state.topDrawCards) ? state.topDrawCards : [];
  const maxShow = Math.min(topCards.length, 5);

  for (let i = 0; i < maxShow; i++) {
    const cardEl = document.createElement("div");
    cardEl.classList.add("card");

    if (i === 0) {
      // Top card â†’ real back image
      const img = document.createElement("img");
      img.src = "/cards/back.png";
      cardEl.appendChild(img);
    } else {
      // Lower cards â†’ yellow filler card
      const filler = document.createElement("div");
      filler.className = "yellow-card";
      cardEl.appendChild(filler);
    }

    // Offset each card slightly
    cardEl.style.top = (i * 4) + "px";
    cardEl.style.left = (i * 4) + "px";

    deckDiv.appendChild(cardEl);
  }

  deckCountDiv.textContent = state.deckCount + " cards";
}

/* ============================================================
   RENDER DISCARD
============================================================ */
function renderDiscard(state) {
  discardPileDiv.innerHTML = "";
  discardPileDiv.classList.remove("empty");

  if (!state || state.discardCount === 0 || !state.topDiscardCard) {
    discardPileDiv.classList.add("empty");
    discardCountDiv.textContent = "Discarded: 0";
    return;
  }

  const img = document.createElement("img");
  img.src = getCardImgSrc(state.topDiscardCard);
  img.style.width = "70px";
  img.style.height = "100px";
  img.style.borderRadius = "6px";
  img.style.border = "3px solid #000";

  discardPileDiv.appendChild(img);
  discardCountDiv.textContent = "Discarded: " + state.discardCount;
}

/* ============================================================
   RENDER PLAYERS + HANDS (SANITIZED)
============================================================ */
function renderPlayers(state) {
  if (!state || !Array.isArray(state.players) || !Array.isArray(state.hands)) {
    return;
  }

  // Group hand values by player ID
  const handsByPlayer = {};
  state.hands.forEach(h => {
    if (!h || h.player_id == null) return;
    if (!handsByPlayer[h.player_id]) handsByPlayer[h.player_id] = [];
    handsByPlayer[h.player_id].push(h.value);
  });

  // Reset all seats
  seatIds.forEach(id => {
    const cell = document.getElementById(id);
    if (!cell) return;

    const nameDiv = cell.querySelector(".player-name");
    if (nameDiv) {
      nameDiv.textContent = "Empty Seat";
    }

    cell.classList.remove(
      "active-player",
      "stayed-player",
      "target-eligible",
      "target-ineligible"
    );

    const slots = cell.querySelectorAll(".card-row .card");
    slots.forEach(slot => {
      slot.innerHTML = "";
    });
  });

  // Render seated players
  state.players.forEach((p, index) => {
    if (!p || index >= seatIds.length) return;

    const cellId = seatIds[index];
    const cell = document.getElementById(cellId);
    if (!cell) return;

    const nameDiv = cell.querySelector(".player-name");
    if (!nameDiv) return;

    const handValues = handsByPlayer[p.id] || [];
    const roundScore = computeRoundScore(handValues);
    const totalScore = p.total_score || 0;
    const safeName = sanitizeNameSafe(p.name || "Player");

    // Clear any previous content (avoid innerHTML injection)
    nameDiv.textContent = "";

    // Dealer chip (if this player started the round)
    if (state.roundStarterId === p.id) {
      const dealerSpan = document.createElement("span");
      dealerSpan.className = "dealer-chip";
      dealerSpan.textContent = "D";
      nameDiv.appendChild(dealerSpan);
    }

    // Text: "<Name> â€” <roundScore> / <totalScore>"
    const label = document.createTextNode(
      `${safeName} â€” ${roundScore} / ${totalScore}`
    );
    nameDiv.appendChild(label);

    // Visual state: stayed / active
    if (p.stayed) {
      cell.classList.add("stayed-player");
    }

    if (
      state.currentPlayerId === p.id &&
      !p.stayed &&
      p.active &&
      !state.roundOver &&
      !state.paused
    ) {
      cell.classList.add("active-player");
    }

    // Render this player's cards into their slots
    const slots = cell.querySelectorAll(".card-row .card");
    slots.forEach((slot, i) => {
      slot.innerHTML = "";
      if (i < handValues.length) {
        const v = handValues[i];
        const img = document.createElement("img");
        img.src = getCardImgSrc(v);
        slot.appendChild(img);
      }
    });
  });

  applyTargetSelection(state);
}

/* ============================================================
   TARGET SELECTION MODE
============================================================ */
function applyTargetSelection(state) {
  // Clear previous targeting state and handlers
  seatIds.forEach(id => {
    const cell = document.getElementById(id);
    if (!cell) return;
    cell.classList.remove("target-eligible", "target-ineligible");
    cell.onclick = null;
  });

  if (!state || !state.pendingActionType) return;

  const actorId = state.pendingActionActorId;
  const action = state.pendingActionType;
  const players = Array.isArray(state.players) ? state.players : [];

  players.forEach((p, index) => {
    if (!p) return;

    const cellId = seatIds[index];
    const cell = document.getElementById(cellId);
    if (!cell) return;

    let eligible = false;

    if (action === "Freeze") {
      eligible = p.active && !p.stayed && p.id !== actorId;
    }

    if (action === "Swap") {
      eligible = p.active;
    }

    if (action === "Take3") {
      eligible = p.active && !p.stayed;
    }

    if (action === "SecondChance") {
      eligible = false;
    }

    if (eligible) {
      cell.classList.add("target-eligible");
      cell.onclick = () => {
        socket.emit("actionTarget", {
          roomCode,
          playerId: actorId,
          action,
          targetId: p.id
        });
      };
    } else {
      cell.classList.add("target-ineligible");
    }
  });
}

/* ============================================================
   BUTTON ENABLE/DISABLE LOGIC
============================================================ */
function updateButtons(state) {
  if (!state) return;

  const isMyTurn =
    state.currentPlayerId === playerId &&
    !state.roundOver &&
    !state.paused &&
    !state.pendingActionType;

  // Deck visual state
  if (isMyTurn) {
    deckDiv.classList.add("deck-clickable");
  } else {
    deckDiv.classList.remove("deck-clickable");
  }

  if (state.final_round) {
    statusDiv.textContent = "FINAL ROUND â€” Everyone gets one last turn.";
  }

  const gameNotStarted = state.deckCount === 0;

  // Deck clickable only on your turn
  deckDiv.classList.toggle("disabled", !isMyTurn);

  // Stay/Pass only appear AFTER drawing a card and when game started
  if (isMyTurn && hasDrawnThisTurn && !gameNotStarted) {
    stayButton.style.display = "block";
    passButton.style.display = "block";
  } else {
    stayButton.style.display = "none";
    passButton.style.display = "none";
  }

  // End Round button enabled only when round is over and not paused
  endTurnsButton.disabled = !state.roundOver || state.paused;

  // Status logic
  if (state.paused) {
    statusDiv.textContent = "Game paused â€” waiting for disconnected players.";
    return;
  }

  if (state.roundOver) {
    statusDiv.textContent = "Round over. Click End Round.";
    return;
  }

  if (state.pendingActionType) {
    const actor = (state.players || []).find(p => p.id === state.pendingActionActorId);
    const safeActorName = actor ? sanitizeNameSafe(actor.name) : "A player";

    if (actor && actor.id === playerId) {
      statusDiv.textContent = `Choose a target for ${state.pendingActionType}`;
    } else {
      statusDiv.textContent = `${safeActorName} is choosing a targetâ€¦`;
    }
    return;
  }

  if (isMyTurn && !gameNotStarted) {
    const me = (state.players || []).find(p => p.id === playerId);
    const safeMeName = me ? sanitizeNameSafe(me.name) : "Player";
    statusDiv.textContent = `Your turn, ${safeMeName}.`;
  } else {
    const current = (state.players || []).find(p => p.id === state.currentPlayerId);
    const safeCurrentName = current ? sanitizeNameSafe(current.name) : null;
    statusDiv.textContent = safeCurrentName
      ? `Current player: ${safeCurrentName}`
      : "Waiting for playersâ€¦";
  }
}

/* ============================================================
   PAUSE OVERLAY
============================================================ */
function updatePauseOverlay(state) {
  if (!state) return;

  if (state.paused) {
    const disconnectedNames = (state.disconnectedPlayers || [])
      .map(p => sanitizeNameSafe(p.name))
      .filter(Boolean)
      .join(", ");

    pauseOverlay.textContent = disconnectedNames
      ? `Game Paused â€” Waiting for ${disconnectedNames}`
      : "Game Paused â€” Waiting for players to reconnect";

    pauseOverlay.style.display = "flex";
  } else {
    pauseOverlay.style.display = "none";
  }
}

/* ============================================================
   SOUND + ANIMATION TRIGGERS
============================================================ */
function detectSoundAndAnimationEvents(state) {
  if (!state) return;

  if (!lastState) {
    lastState = state;
    return;
  }

  // Deck creation / shuffle
  if (lastState.deckCount === 0 && state.deckCount > 0) {
     playSound("shuffle");
  }

  // Bust detection
  const prevBusts = new Set(
    (lastState.players || []).filter(p => p.round_bust).map(p => p.id)
  );
  const newBusts = (state.players || []).filter(
    p => p.round_bust && !prevBusts.has(p.id)
  );
  if (newBusts.length > 0) {
    playSound("bust");
  }

  // Detect new cards drawn
  if ((state.hands || []).length > (lastState.hands || []).length) {
    const prevCount = lastState.hands.length;
    const newEntries = state.hands.slice(prevCount);

    newEntries.forEach(h => {
      if (!h) return;
      const newCard = h.value;
      const playerIdOfCard = h.player_id ?? h.playerId;

      const seatIndex = (state.players || []).findIndex(p => p.id === playerIdOfCard);
      if (seatIndex >= 0 && seatIndex < seatIds.length) {
        animateCardToSeat(newCard, seatIndex);
      }

        if (newCard === "Second Chance") {
          playSound("secondChance");
        } else if (newCard === "6-") {
          playSound("sixMinus");
        } else if (["Freeze", "Swap", "Take3", "Take 3"].includes(newCard)) {
          playSound("action");
        } else {
          playSound("draw");
        }

  }

  lastState = state;
}

/* ============================================================
   SOCKET STATE UPDATE (DEFENSIVE)
============================================================ */
socket.on("stateUpdate", (state) => {
  // Basic shape validation
  if (!state || typeof state !== "object") return;

  // Detect deck change BEFORE overwriting currentState
  const oldDeckCount = currentState ? currentState.deckCount : null;
  const newDeckCount = state.deckCount;

  // Save new state
  currentState = state;

  // If it's no longer our turn, reset "has drawn" flag
  if (state.currentPlayerId !== playerId) {
    hasDrawnThisTurn = false;
  }

  // Second Chance popup only for the acting player
  if (
    state.pendingActionType === "SecondChancePrompt" &&
    state.pendingActionActorId === playerId
  ) {
    document.getElementById("second-chance-popup").style.display = "block";
  } else {
    document.getElementById("second-chance-popup").style.display = "none";
  }

  // Final round visual cue
  if (state.final_round) {
    document.body.classList.add("final-round");
  } else {
    document.body.classList.remove("final-round");
  }

  // Round display
  const roundDisplay = document.getElementById("round-display");
  if (roundDisplay) {
    roundDisplay.textContent = "Round " + (state.roundNumber || 1);
  }

  /* ============================================================
     DECK ANIMATION (Flick + Thickness)
     Runs ONLY when the server confirms a card was drawn
  ============================================================ */
  if (oldDeckCount !== null && newDeckCount < oldDeckCount) {
    animateDeckDraw();   // your new flick animation
    updateDeckStep();    // your old deck thickness animation
  }

  detectSoundAndAnimationEvents(state);
  renderDeck(state);
  renderDiscard(state);
  renderPlayers(state);
  updateButtons(state);
  updatePauseOverlay(state);
});


/* ============================================================
   ON CONNECT â†’ LOAD META + JOIN ROOM
============================================================ */
socket.on("connect", async () => {
  // If identifiers are invalid, don't try to join
  if (!playerId || !roomCode) return;

  await loadCardMeta();

  // Use sanitized roomCode and numeric playerId
  socket.emit("joinRoom", { roomCode, playerId });
});

/* ============================================================
   UI EVENTS
============================================================ */

// Draw card
deckDiv.addEventListener("click", () => {
  // Safety check: ensure we have state before interacting
  if (!currentState) return;

  const isMyTurn =
    currentState.currentPlayerId === playerId &&
    !currentState.roundOver &&
    !currentState.paused &&
    !currentState.pendingActionType;

  if (!isMyTurn) return;

  // Prevent multiple draws per turn client-side
  if (hasDrawnThisTurn) return;
  hasDrawnThisTurn = true;

  socket.emit("drawCard", { roomCode, playerId });
});

// Stay
stayButton.addEventListener("click", () => {
  if (!currentState) return;

  const isMyTurn =
    currentState.currentPlayerId === playerId &&
    !currentState.roundOver &&
    !currentState.paused &&
    !currentState.pendingActionType;

  if (!isMyTurn) return;

  socket.emit("stay", { roomCode, playerId });
});

// Pass
passButton.addEventListener("click", () => {
  if (!currentState) return;

  const isMyTurn =
    currentState.currentPlayerId === playerId &&
    !currentState.roundOver &&
    !currentState.paused &&
    !currentState.pendingActionType;

  if (!isMyTurn) return;

  socket.emit("pass", { roomCode, playerId });
});

// End Round
endTurnsButton.addEventListener("click", () => {
  if (!roomCode) return;
  socket.emit("endRound", { roomCode });
});

// Second Chance responses
document.getElementById("sc-yes").onclick = () => {
  socket.emit("secondChanceResponse", { roomCode, playerId, use: true });
  document.getElementById("second-chance-popup").style.display = "none";
};

document.getElementById("sc-no").onclick = () => {
  socket.emit("secondChanceResponse", { roomCode, playerId, use: false });
  document.getElementById("second-chance-popup").style.display = "none";
};

// Test Sounds Popup
const testSoundsBtn = document.getElementById("test-sounds-btn");
const soundPopup = document.getElementById("sound-popup");
const closeSoundPopup = document.getElementById("close-sound-popup");

if (testSoundsBtn && soundPopup && closeSoundPopup) {
  testSoundsBtn.addEventListener("click", () => {
    soundPopup.style.display = "block";
  });

  closeSoundPopup.addEventListener("click", () => {
    soundPopup.style.display = "none";
  });

  // Play sound when clicking a sound name
  document.querySelectorAll(".sound-item").forEach(item => {
    item.addEventListener("click", () => {
      const soundName = item.getAttribute("data-sound");
      if (soundName) {
        playSound(soundName);
      }

      document.querySelectorAll(".sound-item").forEach(i =>
        i.classList.remove("selected")
      );
      item.classList.add("selected");
    });
  });
}

// Remove player (admin control)
removeBtn.addEventListener("click", () => {
  const rawName = removeNameInput.value.trim();
  const safeName = sanitizeNameSafe(rawName);
  if (!safeName || !roomCode) return;

  socket.emit("removePlayer", { roomCode, name: safeName });
  removeNameInput.value = "";
});

/* ============================================================
   INITIAL STATUS
============================================================ */
statusDiv.textContent = "Connecting to roomâ€¦";

</script>

</body>
</html>


